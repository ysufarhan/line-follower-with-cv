from picamera2 import Picamera2
import cv2
import numpy as np
import time
import serial
import skfuzzy as fuzz
from skfuzzy import control as ctrl

class ErrorFilter:
    def __init__(self, window_size=5):
        self.window_size = window_size
        self.error_history = []
        self.alpha = 0.6

    def filter_error(self, error):
        self.error_history.append(error)
        if len(self.error_history) > self.window_size:
            self.error_history.pop(0)
        
        sorted_errors = sorted(self.error_history)
        median_error = sorted_errors[len(sorted_errors)//2]
        
        if len(self.error_history) > 1:
            prev_filtered = sorted_errors[-2] if len(sorted_errors) > 1 else median_error
            smoothed_error = self.alpha * median_error + (1 - self.alpha) * prev_filtered
        else:
            smoothed_error = median_error
        return int(smoothed_error)

class LineRecovery:
    def __init__(self):
        self.lost_count = 0
        self.last_valid_error = 0
        self.search_direction = 1
        self.recovery_speed = 40
        
    def handle_line_lost(self, ser):
        self.lost_count += 1
        
        if self.lost_count < 10:
            self.send_motor_commands(ser, 0, 0)
            return "stop"
        elif self.lost_count < 30:
            self.send_motor_commands(ser, -30, -30)
            return "reverse"
        else:
            if self.last_valid_error > 0:
                self.send_motor_commands(ser, self.recovery_speed, -self.recovery_speed)
                return "search_right"
            else:
                self.send_motor_commands(ser, -self.recovery_speed, self.recovery_speed)
                return "search_left"
    
    def line_found(self, error):
        self.lost_count = 0
        self.last_valid_error = error
        
    def send_motor_commands(self, ser, pwm_kiri, pwm_kanan):
        if ser:
            try:
                cmd = f"{pwm_kiri},{pwm_kanan}\n"
                ser.write(cmd.encode())
                ser.flush()
            except Exception as e:
                print(f"[SERIAL ERROR] {e}")

def setup_fuzzy_logic():
    error = ctrl.Antecedent(np.arange(-300, 301, 1), 'error')
    delta = ctrl.Antecedent(np.arange(-200, 201, 1), 'delta')
    output = ctrl.Consequent(np.arange(-200, 201, 1), 'output')

    error['NL'] = fuzz.trimf(error.universe, [-300, -200, -80])
    error['NS'] = fuzz.trimf(error.universe, [-120, -50, -10])
    error['Z']  = fuzz.trimf(error.universe, [-25, 0, 25])
    error['PS'] = fuzz.trimf(error.universe, [10, 50, 120])
    error['PL'] = fuzz.trimf(error.universe, [80, 200, 300])

    delta['NL'] = fuzz.trimf(delta.universe, [-200, -100, -40])
    delta['NS'] = fuzz.trimf(delta.universe, [-60, -25, -5])
    delta['Z']  = fuzz.trimf(delta.universe, [-15, 0, 15])
    delta['PS'] = fuzz.trimf(delta.universe, [5, 25, 60])
    delta['PL'] = fuzz.trimf(delta.universe, [40, 100, 200])

    output['L']  = fuzz.trimf(output.universe, [-200, -120, -80])
    output['LS'] = fuzz.trimf(output.universe, [-100, -50, -15])
    output['Z']  = fuzz.trimf(output.universe, [-20, 0, 20])
    output['RS'] = fuzz.trimf(output.universe, [15, 50, 100])
    output['R']  = fuzz.trimf(output.universe, [80, 120, 200])

    rules = [
        ctrl.Rule(error['NL'] & delta['NL'], output['L']),
        ctrl.Rule(error['NL'] & delta['NS'], output['LS']),
        ctrl.Rule(error['NL'] & delta['Z'], output['LS']),
        ctrl.Rule(error['NL'] & delta['PS'], output['Z']),
        ctrl.Rule(error['NL'] & delta['PL'], output['Z']),

        ctrl.Rule(error['NS'] & delta['NL'], output['LS']),
        ctrl.Rule(error['NS'] & delta['NS'], output['LS']),
        ctrl.Rule(error['NS'] & delta['Z'], output['LS']),
        ctrl.Rule(error['NS'] & delta['PS'], output['Z']),
        ctrl.Rule(error['NS'] & delta['PL'], output['Z']),

        ctrl.Rule(error['Z'] & delta['NL'], output['LS']),
        ctrl.Rule(error['Z'] & delta['NS'], output['Z']),
        ctrl.Rule(error['Z'] & delta['Z'], output['Z']),
        ctrl.Rule(error['Z'] & delta['PS'], output['Z']),
        ctrl.Rule(error['Z'] & delta['PL'], output['RS']),

        ctrl.Rule(error['PS'] & delta['NL'], output['Z']),
        ctrl.Rule(error['PS'] & delta['NS'], output['Z']),
        ctrl.Rule(error['PS'] & delta['Z'], output['RS']),
        ctrl.Rule(error['PS'] & delta['PS'], output['RS']),
        ctrl.Rule(error['PS'] & delta['PL'], output['RS']),

        ctrl.Rule(error['PL'] & delta['NL'], output['Z']),
        ctrl.Rule(error['PL'] & delta['NS'], output['Z']),
        ctrl.Rule(error['PL'] & delta['Z'], output['RS']),
        ctrl.Rule(error['PL'] & delta['PS'], output['RS']),
        ctrl.Rule(error['PL'] & delta['PL'], output['R']),
    ]

    control_system = ctrl.ControlSystem(rules)
    return ctrl.ControlSystemSimulation(control_system)

def setup_camera():
    picam2 = Picamera2()
    config = picam2.create_still_configuration(main={"size": (640, 480)})
    picam2.configure(config)
    picam2.start()
    return picam2

def setup_serial():
    try:
        ser = serial.Serial('/dev/ttyAMA0', 115200, timeout=1)
        print("[UART] Port serial berhasil dibuka")
        return ser
    except Exception as e:
        print(f"[UART ERROR] Gagal membuka serial port: {e}")
        return None

def process_image(frame):
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
    gray = clahe.apply(gray)
    
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    
    _, binary = cv2.threshold(blurred, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
    
    height, width = binary.shape
    roi_start = int(height * 0.6)
    roi = binary[roi_start:height, int(width*0.1):int(width*0.9)]
    
    return gray, binary, roi, roi_start

def calculate_line_position(roi, roi_start, frame_width):
    kernel = np.ones((5,5), np.uint8)
    roi_clean = cv2.morphologyEx(roi, cv2.MORPH_CLOSE, kernel)
    roi_clean = cv2.morphologyEx(roi_clean, cv2.MORPH_OPEN, kernel)
    
    contours, _ = cv2.findContours(roi_clean, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    if contours:
        largest_contour = max(contours, key=cv2.contourArea)
        
        if cv2.contourArea(largest_contour) > 200:
            M = cv2.moments(largest_contour)
            if M['m00'] > 0:
                cx = int(M['m10'] / M['m00']) + int(frame_width*0.1)
                cy = int(M['m01'] / M['m00']) + roi_start
                return True, cx, cy, largest_contour
    
    return False, 0, 0, None

def compute_fuzzy_control(fuzzy_ctrl, error_val, delta_error):
    try:
        fuzzy_ctrl.input['error'] = np.clip(error_val, -300, 300)
        fuzzy_ctrl.input['delta'] = np.clip(delta_error, -200, 200)
        fuzzy_ctrl.compute()
        return np.clip(fuzzy_ctrl.output['output'], -200, 200)
    except Exception as e:
        print(f"[FLC ERROR] {e}")
        return 0.0

def calculate_motor_pwm(kontrol, base_pwm=55, scaling_factor=0.15):
    if abs(kontrol) < 5:
        kontrol_scaled = 0
    else:
        kontrol_scaled = kontrol * scaling_factor

    pwm_kiri = base_pwm + kontrol_scaled
    pwm_kanan = base_pwm - kontrol_scaled

    pwm_kiri = max(30, min(80, pwm_kiri))
    pwm_kanan = max(30, min(80, pwm_kanan))

    return int(pwm_kiri), int(pwm_kanan)

def send_motor_commands(ser, pwm_kiri, pwm_kanan):
    if ser:
        try:
            cmd = f"{pwm_kiri},{pwm_kanan}\n"
            ser.write(cmd.encode())
            ser.flush()
        except Exception as e:
            print(f"[SERIAL ERROR] {e}")

def main():
    fuzzy_ctrl = setup_fuzzy_logic()
    picam2 = setup_camera()
    ser = setup_serial()
    error_filter = ErrorFilter(window_size=5)
    line_recovery = LineRecovery()

    prev_error = 0
    frame_count = 0
    
    print("[INFO] Warming up camera...")
    time.sleep(2)

    try:
        while True:
            frame = picam2.capture_array()
            height, width = frame
            height, width = frame.shape[:2]

            gray, binary, roi, roi_start = process_image(frame)

            found, cx, cy, contour = calculate_line_position(roi, roi_start, width)

            if found:
                error = cx - (width // 2)
                filtered_error = error_filter.filter_error(error)
                delta_error = filtered_error - prev_error
                kontrol = compute_fuzzy_control(fuzzy_ctrl, filtered_error, delta_error)
                pwm_kiri, pwm_kanan = calculate_motor_pwm(kontrol)

                send_motor_commands(ser, pwm_kiri, pwm_kanan)

                line_recovery.line_found(error)
                prev_error = filtered_error

                # Optional: Debugging visuals
                cv2.circle(frame, (cx, cy), 5, (0, 255, 0), -1)
                cv2.drawContours(frame, [contour + [int(width*0.1), roi_start]], -1, (255, 0, 0), 2)
            else:
                action = line_recovery.handle_line_lost(ser)
                print(f"[WARNING] Line lost. Taking action: {action}")

            # Optional: display windows for debugging
            # cv2.imshow("Frame", frame)
            # cv2.imshow("Binary", binary)
            # cv2.imshow("ROI", roi)

            frame_count += 1
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break

    except KeyboardInterrupt:
        print("[EXIT] Dihentikan oleh pengguna.")

    finally:
        send_motor_commands(ser, 0, 0)
        if ser:
            ser.close()
        picam2.stop()
        cv2.destroyAllWindows()
        print("[CLEANUP] Program selesai dan resources dibersihkan.")

if __name__ == "__main__":
    main()

