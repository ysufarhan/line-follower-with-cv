from picamera2 import Picamera2
import cv2
import numpy as np
import time
import serial
import skfuzzy as fuzz
from skfuzzy import control as ctrl

class ErrorFilter:
    def __init__(self, window_size=3):
        self.window_size = window_size
        self.error_history = []
        self.alpha = 0.7

    def filter_error(self, error):
        self.error_history.append(error)
        if len(self.error_history) > self.window_size:
            self.error_history.pop(0)
        avg_error = sum(self.error_history) / len(self.error_history)
        if len(self.error_history) > 1:
            prev_avg = sum(self.error_history[:-1]) / len(self.error_history[:-1])
            smoothed_error = self.alpha * avg_error + (1 - self.alpha) * prev_avg
        else:
            smoothed_error = avg_error
        return int(smoothed_error)

def setup_fuzzy_logic():
    # Antecedent dan Consequent
    error = ctrl.Antecedent(np.arange(-200, 201, 1), 'error')
    delta = ctrl.Antecedent(np.arange(-150, 151, 1), 'delta')
    output = ctrl.Consequent(np.arange(-150, 151, 1), 'output')

    # IMPROVED ERROR MEMBERSHIP FUNCTIONS - Lebih sensitif di area tengah
    error['NL'] = fuzz.trimf(error.universe, [-200, -120, -40])  # Negative Large
    error['NM'] = fuzz.trimf(error.universe, [-60, -25, -8])    # Negative Medium  
    error['NS'] = fuzz.trimf(error.universe, [-15, -5, 0])      # Negative Small
    error['Z']  = fuzz.trimf(error.universe, [-3, 0, 3])        # Zero (lebih sempit)
    error['PS'] = fuzz.trimf(error.universe, [0, 5, 15])        # Positive Small
    error['PM'] = fuzz.trimf(error.universe, [8, 25, 60])       # Positive Medium
    error['PL'] = fuzz.trimf(error.universe, [40, 120, 200])    # Positive Large

    # IMPROVED DELTA MEMBERSHIP FUNCTIONS - Lebih responsif terhadap perubahan
    delta['NL'] = fuzz.trimf(delta.universe, [-150, -60, -20])  # Negative Large
    delta['NM'] = fuzz.trimf(delta.universe, [-35, -15, -5])    # Negative Medium
    delta['NS'] = fuzz.trimf(delta.universe, [-10, -3, 0])      # Negative Small
    delta['Z']  = fuzz.trimf(delta.universe, [-2, 0, 2])        # Zero (lebih sempit)
    delta['PS'] = fuzz.trimf(delta.universe, [0, 3, 10])        # Positive Small
    delta['PM'] = fuzz.trimf(delta.universe, [5, 15, 35])       # Positive Medium
    delta['PL'] = fuzz.trimf(delta.universe, [20, 60, 150])     # Positive Large

    # IMPROVED OUTPUT MEMBERSHIP FUNCTIONS - Kontrol yang lebih halus
    output['LL'] = fuzz.gaussmf(output.universe, -120, 15)      # Left Large
    output['LM'] = fuzz.gaussmf(output.universe, -60, 10)       # Left Medium
    output['LS'] = fuzz.gaussmf(output.universe, -20, 6)        # Left Small
    output['Z']  = fuzz.gaussmf(output.universe, 0, 4)          # Zero (lebih sempit)
    output['RS'] = fuzz.gaussmf(output.universe, 20, 6)         # Right Small
    output['RM'] = fuzz.gaussmf(output.universe, 60, 10)        # Right Medium
    output['RL'] = fuzz.gaussmf(output.universe, 120, 15)       # Right Large

    # IMPROVED FUZZY RULES - Lebih detail dan presisi
    rules = [
        # Error NL (Negative Large) - Robot jauh ke kiri dari garis
        ctrl.Rule(error['NL'] & delta['NL'], output['LL']),
        ctrl.Rule(error['NL'] & delta['NM'], output['LL']),
        ctrl.Rule(error['NL'] & delta['NS'], output['LM']),
        ctrl.Rule(error['NL'] & delta['Z'], output['LM']),
        ctrl.Rule(error['NL'] & delta['PS'], output['LS']),
        ctrl.Rule(error['NL'] & delta['PM'], output['LS']),
        ctrl.Rule(error['NL'] & delta['PL'], output['Z']),

        # Error NM (Negative Medium)
        ctrl.Rule(error['NM'] & delta['NL'], output['LL']),
        ctrl.Rule(error['NM'] & delta['NM'], output['LM']),
        ctrl.Rule(error['NM'] & delta['NS'], output['LM']),
        ctrl.Rule(error['NM'] & delta['Z'], output['LS']),
        ctrl.Rule(error['NM'] & delta['PS'], output['LS']),
        ctrl.Rule(error['NM'] & delta['PM'], output['Z']),
        ctrl.Rule(error['NM'] & delta['PL'], output['Z']),

        # Error NS (Negative Small) - Robot sedikit ke kiri
        ctrl.Rule(error['NS'] & delta['NL'], output['LM']),
        ctrl.Rule(error['NS'] & delta['NM'], output['LS']),
        ctrl.Rule(error['NS'] & delta['NS'], output['LS']),
        ctrl.Rule(error['NS'] & delta['Z'], output['LS']),
        ctrl.Rule(error['NS'] & delta['PS'], output['Z']),
        ctrl.Rule(error['NS'] & delta['PM'], output['Z']),
        ctrl.Rule(error['NS'] & delta['PL'], output['RS']),

        # Error Z (Zero) - Robot tepat di tengah garis
        ctrl.Rule(error['Z'] & delta['NL'], output['LS']),
        ctrl.Rule(error['Z'] & delta['NM'], output['LS']),
        ctrl.Rule(error['Z'] & delta['NS'], output['Z']),
        ctrl.Rule(error['Z'] & delta['Z'], output['Z']),
        ctrl.Rule(error['Z'] & delta['PS'], output['Z']),
        ctrl.Rule(error['Z'] & delta['PM'], output['RS']),
        ctrl.Rule(error['Z'] & delta['PL'], output['RS']),

        # Error PS (Positive Small) - Robot sedikit ke kanan
        ctrl.Rule(error['PS'] & delta['NL'], output['LS']),
        ctrl.Rule(error['PS'] & delta['NM'], output['Z']),
        ctrl.Rule(error['PS'] & delta['NS'], output['Z']),
        ctrl.Rule(error['PS'] & delta['Z'], output['RS']),
        ctrl.Rule(error['PS'] & delta['PS'], output['RS']),
        ctrl.Rule(error['PS'] & delta['PM'], output['RS']),
        ctrl.Rule(error['PS'] & delta['PL'], output['RM']),

        # Error PM (Positive Medium)
        ctrl.Rule(error['PM'] & delta['NL'], output['Z']),
        ctrl.Rule(error['PM'] & delta['NM'], output['Z']),
        ctrl.Rule(error['PM'] & delta['NS'], output['RS']),
        ctrl.Rule(error['PM'] & delta['Z'], output['RS']),
        ctrl.Rule(error['PM'] & delta['PS'], output['RM']),
        ctrl.Rule(error['PM'] & delta['PM'], output['RM']),
        ctrl.Rule(error['PM'] & delta['PL'], output['RL']),

        # Error PL (Positive Large) - Robot jauh ke kanan dari garis
        ctrl.Rule(error['PL'] & delta['NL'], output['Z']),
        ctrl.Rule(error['PL'] & delta['NM'], output['RS']),
        ctrl.Rule(error['PL'] & delta['NS'], output['RS']),
        ctrl.Rule(error['PL'] & delta['Z'], output['RM']),
        ctrl.Rule(error['PL'] & delta['PS'], output['RM']),
        ctrl.Rule(error['PL'] & delta['PM'], output['RL']),
        ctrl.Rule(error['PL'] & delta['PL'], output['RL']),
    ]

    control_system = ctrl.ControlSystem(rules)
    return ctrl.ControlSystemSimulation(control_system)

def setup_camera():
    picam2 = Picamera2()
    config = picam2.create_still_configuration(main={"size": (320, 240)})
    picam2.configure(config)
    picam2.start()
    return picam2

def setup_serial():
    try:
        ser = serial.Serial('/dev/ttyAMA0', 115200, timeout=1)
        print("[UART] Port serial berhasil dibuka")
        return ser
    except Exception as e:
        print(f"[UART ERROR] Gagal membuka serial port: {e}")
        return None

def process_image(frame):
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    
    # PERBAIKAN: Gunakan threshold adaptif untuk hasil yang lebih konsisten
    # Jika garis HITAM di atas background PUTIH, gunakan THRESH_BINARY_INV
    # Jika garis PUTIH di atas background HITAM, gunakan THRESH_BINARY
    
    # Coba deteksi otomatis: periksa rata-rata intensitas
    mean_intensity = np.mean(gray)
    
    if mean_intensity > 127:  # Background terang, garis gelap
        _, binary = cv2.threshold(blurred, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
        print(f"[THRESH] Background terang detected (mean: {mean_intensity:.1f}) - BINARY_INV")
    else:  # Background gelap, garis terang
        _, binary = cv2.threshold(blurred, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
        print(f"[THRESH] Background gelap detected (mean: {mean_intensity:.1f}) - BINARY")
    
    # Perbaikan ROI - ambil area tengah yang lebih besar untuk deteksi yang lebih stabil
    roi = binary[140:240, :]  # Diperluas dari 160:240 ke 140:240
    return gray, binary, roi

def calculate_line_position(roi):
    # Perbaikan morphological operations untuk deteksi garis yang lebih baik
    kernel = np.ones((3,3), np.uint8)
    roi_clean = cv2.morphologyEx(roi, cv2.MORPH_CLOSE, kernel)
    roi_clean = cv2.morphologyEx(roi_clean, cv2.MORPH_OPEN, kernel)
    
    # Tambahan: Erosi untuk menipiskan garis jika terlalu tebal
    roi_clean = cv2.erode(roi_clean, kernel, iterations=1)
    
    M = cv2.moments(roi_clean)
    if M['m00'] > 50:  # Turunkan threshold untuk deteksi yang lebih sensitif
        cx = int(M['m10'] / M['m00'])
        cy = int(M['m01'] / M['m00']) + 140  # Sesuaikan dengan ROI baru (140:240)
        
        # PERBAIKAN: Tambahkan validasi apakah cx dalam range yang wajar
        if 0 <= cx <= 320:  # Pastikan cx dalam batas frame
            return True, cx, cy
        else:
            print(f"[WARNING] cx out of range: {cx}")
            return False, 0, 0
    return False, 0, 0

def compute_fuzzy_control(fuzzy_ctrl, error_val, delta_error):
    try:
        fuzzy_ctrl.input['error'] = np.clip(error_val, -200, 200)
        fuzzy_ctrl.input['delta'] = np.clip(delta_error, -150, 150)
        fuzzy_ctrl.compute()
        return np.clip(fuzzy_ctrl.output['output'], -150, 150)
    except Exception as e:
        print(f"[FLC ERROR] {e}")
        return 0.0

def calculate_motor_pwm(kontrol, base_pwm=55):  # Sedikit naikkan base PWM
    # Improved scaling untuk kontrol yang lebih halus
    kontrol_scaled = 0.15 * np.tanh(kontrol / 70.0) * 80  # Scaling yang lebih halus
    pwm_kiri = base_pwm + kontrol_scaled
    pwm_kanan = base_pwm - kontrol_scaled
    
    # Batasan PWM yang lebih ketat untuk kontrol halus
    pwm_kiri = max(40, min(75, pwm_kiri))
    pwm_kanan = max(40, min(75, pwm_kanan))
    return int(pwm_kiri), int(pwm_kanan)

def send_motor_commands(ser, pwm_kiri, pwm_kanan):
    if ser:
        try:
            cmd = f"{pwm_kiri},{pwm_kanan}\n"
            ser.write(cmd.encode())
            ser.flush()
        except Exception as e:
            print(f"[SERIAL ERROR] {e}")

def main():
    fuzzy_ctrl = setup_fuzzy_logic()
    picam2 = setup_camera()
    ser = setup_serial()
    error_filter = ErrorFilter(window_size=3)

    prev_error = 0
    frame_count = 0

    try:
        while True:
            frame = picam2.capture_array()
            gray, binary, roi = process_image(frame)

            line_detected, cx, cy = calculate_line_position(roi)
            if line_detected:
                error = cx - 160
                error = error_filter.filter_error(error)
                delta_error = error - prev_error
                prev_error = error

                kontrol = compute_fuzzy_control(fuzzy_ctrl, error, delta_error)
                pwm_kiri, pwm_kanan = calculate_motor_pwm(kontrol)
                send_motor_commands(ser, pwm_kiri, pwm_kanan)

                if frame_count % 15 == 0:
                    print(f"[DEBUG] Error: {error:4d}, Delta: {delta_error:4d}, FLC: {kontrol:6.2f}, PWM: L{pwm_kiri} R{pwm_kanan}")
                    if abs(error) < 5:  # Threshold lebih ketat untuk "tepat tengah"
                        print(f"[PERFECT] Robot tepat di tengah garis: {error}")
                    elif abs(error) < 10:
                        print(f"[GOOD] Robot mendekati tengah garis: {error}")
            else:
                send_motor_commands(ser, 0, 0)
                if frame_count % 20 == 0:
                    print("[DEBUG] Garis tidak terdeteksi")

            # Visualisasi dengan informasi threshold
            frame_with_line = frame.copy()
            cv2.line(frame_with_line, (160, 140), (160, 240), (0, 255, 0), 2)  # Sesuaikan dengan ROI baru
            if line_detected:
                cv2.circle(frame_with_line, (cx, cy), 5, (0, 0, 255), -1)
                cv2.putText(frame_with_line, f"E:{error}", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
                cv2.putText(frame_with_line, f"C:{kontrol:.1f}", (10, 50), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
                cv2.putText(frame_with_line, f"Pos:({cx},{cy})", (10, 70), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255, 255, 255), 1)

            cv2.imshow("Camera View", frame_with_line)
            cv2.imshow("Binary Full", binary)  # Tambahkan untuk debug
            cv2.imshow("Threshold ROI", roi)
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break

            frame_count += 1
            time.sleep(0.04)
    except KeyboardInterrupt:
        print("\n[INFO] Dihentikan oleh pengguna")
    finally:
        send_motor_commands(ser, 0, 0)
        if ser:
            ser.close()
        picam2.stop()
        cv2.destroyAllWindows()
        print("[INFO] Program selesai")

if __name__ == "__main__":
    main()
