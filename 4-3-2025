from picamera2 import Picamera2
import cv2
import numpy as np
import time
import serial
import skfuzzy as fuzz
from skfuzzy import control as ctrl

class ErrorFilter:
    def __init__(self, window_size=3):
        self.window_size = window_size
        self.error_history = []
        self.alpha = 0.7  # Smoothing

    def filter_error(self, error):
        self.error_history.append(error)
        if len(self.error_history) > self.window_size:
            self.error_history.pop(0)
        avg_error = sum(self.error_history) / len(self.error_history)
        if len(self.error_history) > 1:
            prev_avg = sum(self.error_history[:-1]) / len(self.error_history[:-1])
            smoothed_error = self.alpha * avg_error + (1 - self.alpha) * prev_avg
        else:
            smoothed_error = avg_error
        return int(smoothed_error)

def setup_fuzzy_logic():
    # Input variables dengan range yang lebih agresif
    error = ctrl.Antecedent(np.arange(-200, 201, 1), 'error')
    delta = ctrl.Antecedent(np.arange(-150, 151, 1), 'delta')
    output = ctrl.Consequent(np.arange(-200, 201, 1), 'output')  # Range output diperluas

    # Membership functions untuk ERROR - Lebih sensitif
    error['NL'] = fuzz.trimf(error.universe, [-200, -120, -40])   # Negative Large
    error['NM'] = fuzz.trimf(error.universe, [-80, -40, -15])    # Negative Medium
    error['NS'] = fuzz.trimf(error.universe, [-25, -10, -3])     # Negative Small
    error['Z']  = fuzz.trimf(error.universe, [-8, 0, 8])         # Zero - dipersempit
    error['PS'] = fuzz.trimf(error.universe, [3, 10, 25])       # Positive Small
    error['PM'] = fuzz.trimf(error.universe, [15, 40, 80])      # Positive Medium
    error['PL'] = fuzz.trimf(error.universe, [40, 120, 200])    # Positive Large

    # Membership functions untuk DELTA ERROR - Lebih responsif
    delta['NL'] = fuzz.trimf(delta.universe, [-150, -80, -25])
    delta['NS'] = fuzz.trimf(delta.universe, [-40, -15, -3])
    delta['Z']  = fuzz.trimf(delta.universe, [-8, 0, 8])
    delta['PS'] = fuzz.trimf(delta.universe, [3, 15, 40])
    delta['PL'] = fuzz.trimf(delta.universe, [25, 80, 150])

    # Membership functions untuk OUTPUT - Lebih agresif
    output['LL'] = fuzz.trimf(output.universe, [-200, -150, -80])  # Left Large
    output['LM'] = fuzz.trimf(output.universe, [-120, -80, -30])   # Left Medium
    output['LS'] = fuzz.trimf(output.universe, [-50, -25, -5])     # Left Small
    output['Z']  = fuzz.trimf(output.universe, [-10, 0, 10])       # Zero - dipersempit
    output['RS'] = fuzz.trimf(output.universe, [5, 25, 50])       # Right Small
    output['RM'] = fuzz.trimf(output.universe, [30, 80, 120])     # Right Medium
    output['RR'] = fuzz.trimf(output.universe, [80, 150, 200])    # Right Large

    # Rules yang lebih agresif untuk respons berbelok
    rules = [
        # Error Negative Large
        ctrl.Rule(error['NL'] & delta['NL'], output['LL']),
        ctrl.Rule(error['NL'] & delta['NS'], output['LL']),
        ctrl.Rule(error['NL'] & delta['Z'], output['LM']),
        ctrl.Rule(error['NL'] & delta['PS'], output['LM']),
        ctrl.Rule(error['NL'] & delta['PL'], output['LS']),

        # Error Negative Medium
        ctrl.Rule(error['NM'] & delta['NL'], output['LL']),
        ctrl.Rule(error['NM'] & delta['NS'], output['LM']),
        ctrl.Rule(error['NM'] & delta['Z'], output['LM']),
        ctrl.Rule(error['NM'] & delta['PS'], output['LS']),
        ctrl.Rule(error['NM'] & delta['PL'], output['Z']),

        # Error Negative Small
        ctrl.Rule(error['NS'] & delta['NL'], output['LM']),
        ctrl.Rule(error['NS'] & delta['NS'], output['LS']),
        ctrl.Rule(error['NS'] & delta['Z'], output['LS']),
        ctrl.Rule(error['NS'] & delta['PS'], output['Z']),
        ctrl.Rule(error['NS'] & delta['PL'], output['RS']),

        # Error Zero
        ctrl.Rule(error['Z'] & delta['NL'], output['LS']),
        ctrl.Rule(error['Z'] & delta['NS'], output['Z']),
        ctrl.Rule(error['Z'] & delta['Z'], output['Z']),
        ctrl.Rule(error['Z'] & delta['PS'], output['Z']),
        ctrl.Rule(error['Z'] & delta['PL'], output['RS']),

        # Error Positive Small
        ctrl.Rule(error['PS'] & delta['NL'], output['LS']),
        ctrl.Rule(error['PS'] & delta['NS'], output['Z']),
        ctrl.Rule(error['PS'] & delta['Z'], output['RS']),
        ctrl.Rule(error['PS'] & delta['PS'], output['RS']),
        ctrl.Rule(error['PS'] & delta['PL'], output['RM']),

        # Error Positive Medium
        ctrl.Rule(error['PM'] & delta['NL'], output['Z']),
        ctrl.Rule(error['PM'] & delta['NS'], output['RS']),
        ctrl.Rule(error['PM'] & delta['Z'], output['RM']),
        ctrl.Rule(error['PM'] & delta['PS'], output['RM']),
        ctrl.Rule(error['PM'] & delta['PL'], output['RR']),

        # Error Positive Large
        ctrl.Rule(error['PL'] & delta['NL'], output['RS']),
        ctrl.Rule(error['PL'] & delta['NS'], output['RM']),
        ctrl.Rule(error['PL'] & delta['Z'], output['RM']),
        ctrl.Rule(error['PL'] & delta['PS'], output['RR']),
        ctrl.Rule(error['PL'] & delta['PL'], output['RR']),
    ]

    control_system = ctrl.ControlSystem(rules)
    return ctrl.ControlSystemSimulation(control_system)

def setup_camera():
    picam2 = Picamera2()
    config = picam2.create_still_configuration(main={"size": (320, 240)})
    picam2.configure(config)
    picam2.start()
    return picam2

def setup_serial():
    try:
        ser = serial.Serial('/dev/ttyAMA0', 115200, timeout=1)
        print("[UART] Port serial berhasil dibuka")
        return ser
    except Exception as e:
        print(f"[UART ERROR] Gagal membuka serial port: {e}")
        return None

def process_image(frame):
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    blurred = cv2.medianBlur(blurred, 5)
    
    # Hanya menggunakan OTSU thresholding
    _, binary = cv2.threshold(blurred, 0, 255, cv2.THRESH_OTSU)
    
    # Invert jika diperlukan (garis hitam pada background putih)
    # Cek apakah mayoritas pixel adalah putih (background)
    white_pixels = np.sum(binary == 255)
    black_pixels = np.sum(binary == 0)
    
    if white_pixels > black_pixels:
        # Jika background putih, invert agar garis menjadi putih
        binary = cv2.bitwise_not(binary)
    
    # ROI dipindah lebih ke depan untuk deteksi lebih awal
    roi_start = 80   # Lebih ke atas dari 120
    roi_end = 160    # Jarak ROI yang cukup
    roi = binary[roi_start:roi_end, :]  
    return gray, binary, roi, roi_start

def calculate_line_position(roi, roi_start=80):
    kernel = np.ones((3,3), np.uint8)
    roi_clean = cv2.morphologyEx(roi, cv2.MORPH_CLOSE, kernel)
    roi_clean = cv2.morphologyEx(roi_clean, cv2.MORPH_OPEN, kernel)
    M = cv2.moments(roi_clean)
    if M['m00'] > 100:
        cx = int(M['m10'] / M['m00'])
        cy = int(M['m01'] / M['m00']) + roi_start  # Sesuaikan dengan ROI baru
        return True, cx, cy
    return False, 0, 0

def compute_fuzzy_control(fuzzy_ctrl, error_val, delta_error):
    try:
        fuzzy_ctrl.input['error'] = np.clip(error_val, -200, 200)
        fuzzy_ctrl.input['delta'] = np.clip(delta_error, -150, 150)
        fuzzy_ctrl.compute()
        return np.clip(fuzzy_ctrl.output['output'], -200, 200)  # Range output diperluas
    except Exception as e:
        print(f"[FLC ERROR] {e}")
        return 0.0

def calculate_motor_pwm(kontrol, base_pwm=45, scaling_factor=0.25):  # PWM dikecilkan
    # Threshold untuk dead zone diperkecil agar lebih responsif
    if abs(kontrol) < 5:  # Diperkecil dari 8 ke 5
        kontrol_scaled = 0
    else:
        kontrol_scaled = kontrol * scaling_factor

    pwm_kiri = base_pwm + kontrol_scaled
    pwm_kanan = base_pwm - kontrol_scaled

    # Range PWM dikecilkan untuk kecepatan yang lebih terkontrol
    pwm_kiri = max(20, min(70, pwm_kiri))    # Range: 20-70 (lebih kecil)
    pwm_kanan = max(20, min(70, pwm_kanan))

    return int(pwm_kiri), int(pwm_kanan)

def send_motor_commands(ser, pwm_kiri, pwm_kanan):
    if ser:
        try:
            cmd = f"{pwm_kiri},{pwm_kanan}\n"
            ser.write(cmd.encode())
            ser.flush()
        except Exception as e:
            print(f"[SERIAL ERROR] {e}")

def main():
    fuzzy_ctrl = setup_fuzzy_logic()
    picam2 = setup_camera()
    ser = setup_serial()
    error_filter = ErrorFilter(window_size=3)

    prev_error = 0
    frame_count = 0

    try:
        while True:
            frame = picam2.capture_array()
            gray, binary, roi, roi_start = process_image(frame)
            line_detected, cx, cy = calculate_line_position(roi, roi_start)

            if line_detected:
                error = cx - 160
                error = error_filter.filter_error(error)
                delta_error = error - prev_error
                prev_error = error

                kontrol = compute_fuzzy_control(fuzzy_ctrl, error, delta_error)
                pwm_kiri, pwm_kanan = calculate_motor_pwm(kontrol)
                send_motor_commands(ser, pwm_kiri, pwm_kanan)

                if frame_count % 15 == 0:
                    print(f"[DEBUG] Error: {error:4d}, Delta: {delta_error:4d}, FLC: {kontrol:6.2f}, PWM: L{pwm_kiri} R{pwm_kanan}")
                    if abs(error) < 10:
                        print(f"[GOOD]  Stabil: Error={error}, PWM Kiri={pwm_kiri}, Kanan={pwm_kanan}")
                    elif abs(error) > 50:
                        print(f"[TURN]  Berbelok: Error={error}, Kontrol={kontrol:.2f}")
            else:
                # Ketika garis hilang, coba gerakan mencari dengan PWM yang lebih kecil
                if frame_count % 10 == 0:
                    send_motor_commands(ser, 35, 45)  # PWM lebih kecil untuk pencarian
                else:
                    send_motor_commands(ser, 0, 0)
                if frame_count % 20 == 0:
                    print("[DEBUG] Garis tidak terdeteksi - mencari...")

            frame_with_line = frame.copy()
            # Gambar garis referensi di tengah frame
            cv2.line(frame_with_line, (160, 80), (160, 160), (0, 255, 0), 2)  # Sesuaikan dengan ROI baru
            # Gambar kotak ROI untuk visualisasi
            cv2.rectangle(frame_with_line, (0, 80), (319, 160), (255, 0, 0), 1)
            
            if line_detected:
                cv2.circle(frame_with_line, (cx, cy), 5, (0, 0, 255), -1)
                cv2.putText(frame_with_line, f"E:{error}", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
                cv2.putText(frame_with_line, f"C:{kontrol:.1f}", (10, 50), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
                cv2.putText(frame_with_line, f"ROI: {roi_start}-{roi_start+80}", (10, 70), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255, 255, 255), 1)

            cv2.imshow("Camera View", frame_with_line)
            cv2.imshow("Threshold ROI", roi)
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break

            frame_count += 1
            time.sleep(0.04)
    except KeyboardInterrupt:
        print("\n[INFO] Dihentikan oleh pengguna")
    finally:
        send_motor_commands(ser, 0, 0)
        if ser:
            ser.close()
        picam2.stop()
        cv2.destroyAllWindows()
        print("[INFO] Program selesai")

if __name__ == "__main__":
    main()
