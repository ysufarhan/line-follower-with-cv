from picamera2 import Picamera2
import cv2
import numpy as np
import time
import serial
import skfuzzy as fuzz
from skfuzzy import control as ctrl
from datetime import datetime

class ErrorFilter:
    def __init__(self, window_size=3):
        self.window_size = window_size
        self.error_history = []

    def filter_error(self, error):
        self.error_history.append(error)
        if len(self.error_history) > self.window_size:
            self.error_history.pop(0)
        return int(sum(self.error_history) / len(self.error_history))

def setup_fuzzy_logic_responsive():
    """Setup FLC dengan range error yang lebih besar tapi output lebih conservative"""
    error = ctrl.Antecedent(np.arange(-160, 161, 1), 'error')
    delta = ctrl.Antecedent(np.arange(-80, 81, 1), 'delta')
    output = ctrl.Consequent(np.arange(-60, 61, 1), 'output')

    # Membership functions dengan overlap lebih besar untuk smooth transition
    error['NL'] = fuzz.trimf(error.universe, [-160, -160, -60])
    error['NM'] = fuzz.trimf(error.universe, [-100, -50, -15])
    error['NS'] = fuzz.trimf(error.universe, [-35, -15, -3])
    error['Z']  = fuzz.trimf(error.universe, [-10, 0, 10])
    error['PS'] = fuzz.trimf(error.universe, [3, 15, 35])
    error['PM'] = fuzz.trimf(error.universe, [15, 50, 100])
    error['PL'] = fuzz.trimf(error.universe, [60, 160, 160])

    delta['NL'] = fuzz.trimf(delta.universe, [-80, -80, -30])
    delta['NM'] = fuzz.trimf(delta.universe, [-50, -20, -8])
    delta['NS'] = fuzz.trimf(delta.universe, [-15, -5, -1])
    delta['Z']  = fuzz.trimf(delta.universe, [-3, 0, 3])
    delta['PS'] = fuzz.trimf(delta.universe, [1, 5, 15])
    delta['PM'] = fuzz.trimf(delta.universe, [8, 20, 50])
    delta['PL'] = fuzz.trimf(delta.universe, [30, 80, 80])

    # Output dengan range lebih kecil untuk mencegah overreaction
    output['L']  = fuzz.trimf(output.universe, [-60, -60, -35])
    output['LM'] = fuzz.trimf(output.universe, [-45, -25, -10])
    output['LS'] = fuzz.trimf(output.universe, [-18, -8, -2])
    output['Z']  = fuzz.trimf(output.universe, [-5, 0, 5])
    output['RS'] = fuzz.trimf(output.universe, [2, 8, 18])
    output['RM'] = fuzz.trimf(output.universe, [10, 25, 45])
    output['R']  = fuzz.trimf(output.universe, [35, 60, 60])

    # Rules dengan lebih konservatif untuk smooth movement
    rules = [
        # Error Negative Large - aggressive correction tapi terbatas
        ctrl.Rule(error['NL'] & delta['NL'], output['L']),
        ctrl.Rule(error['NL'] & delta['NM'], output['LM']),
        ctrl.Rule(error['NL'] & delta['NS'], output['LM']),
        ctrl.Rule(error['NL'] & delta['Z'], output['LS']),
        ctrl.Rule(error['NL'] & delta['PS'], output['LS']),
        ctrl.Rule(error['NL'] & delta['PM'], output['Z']),
        ctrl.Rule(error['NL'] & delta['PL'], output['Z']),

        # Error Negative Medium - moderate correction
        ctrl.Rule(error['NM'] & delta['NL'], output['LM']),
        ctrl.Rule(error['NM'] & delta['NM'], output['LS']),
        ctrl.Rule(error['NM'] & delta['NS'], output['LS']),
        ctrl.Rule(error['NM'] & delta['Z'], output['LS']),
        ctrl.Rule(error['NM'] & delta['PS'], output['Z']),
        ctrl.Rule(error['NM'] & delta['PM'], output['Z']),
        ctrl.Rule(error['NM'] & delta['PL'], output['RS']),

        # Error Negative Small - gentle correction
        ctrl.Rule(error['NS'] & delta['NL'], output['LS']),
        ctrl.Rule(error['NS'] & delta['NM'], output['LS']),
        ctrl.Rule(error['NS'] & delta['NS'], output['Z']),
        ctrl.Rule(error['NS'] & delta['Z'], output['Z']),
        ctrl.Rule(error['NS'] & delta['PS'], output['Z']),
        ctrl.Rule(error['NS'] & delta['PM'], output['Z']),
        ctrl.Rule(error['NS'] & delta['PL'], output['RS']),

        # Error Zero - maintain stability
        ctrl.Rule(error['Z'] & delta['NL'], output['LS']),
        ctrl.Rule(error['Z'] & delta['NM'], output['Z']),
        ctrl.Rule(error['Z'] & delta['NS'], output['Z']),
        ctrl.Rule(error['Z'] & delta['Z'], output['Z']),
        ctrl.Rule(error['Z'] & delta['PS'], output['Z']),
        ctrl.Rule(error['Z'] & delta['PM'], output['Z']),
        ctrl.Rule(error['Z'] & delta['PL'], output['RS']),

        # Error Positive Small - gentle correction
        ctrl.Rule(error['PS'] & delta['NL'], output['LS']),
        ctrl.Rule(error['PS'] & delta['NM'], output['Z']),
        ctrl.Rule(error['PS'] & delta['NS'], output['Z']),
        ctrl.Rule(error['PS'] & delta['Z'], output['Z']),
        ctrl.Rule(error['PS'] & delta['PS'], output['Z']),
        ctrl.Rule(error['PS'] & delta['PM'], output['RS']),
        ctrl.Rule(error['PS'] & delta['PL'], output['RS']),

        # Error Positive Medium - moderate correction
        ctrl.Rule(error['PM'] & delta['NL'], output['LS']),
        ctrl.Rule(error['PM'] & delta['NM'], output['Z']),
        ctrl.Rule(error['PM'] & delta['NS'], output['Z']),
        ctrl.Rule(error['PM'] & delta['Z'], output['RS']),
        ctrl.Rule(error['PM'] & delta['PS'], output['RS']),
        ctrl.Rule(error['PM'] & delta['PM'], output['RS']),
        ctrl.Rule(error['PM'] & delta['PL'], output['RM']),

        # Error Positive Large - aggressive correction tapi terbatas
        ctrl.Rule(error['PL'] & delta['NL'], output['Z']),
        ctrl.Rule(error['PL'] & delta['NM'], output['Z']),
        ctrl.Rule(error['PL'] & delta['NS'], output['RS']),
        ctrl.Rule(error['PL'] & delta['Z'], output['RS']),
        ctrl.Rule(error['PL'] & delta['PS'], output['RM']),
        ctrl.Rule(error['PL'] & delta['PM'], output['RM']),
        ctrl.Rule(error['PL'] & delta['PL'], output['R']),
    ]

    control_system = ctrl.ControlSystem(rules)
    return ctrl.ControlSystemSimulation(control_system)

def setup_camera():
    picam2 = Picamera2()
    config = picam2.create_still_configuration(main={"size": (320, 240)})
    picam2.configure(config)
    picam2.start()
    return picam2

def setup_serial():
    try:
        ser = serial.Serial('/dev/ttyAMA0', 115200, timeout=1)
        print("[UART] Port serial berhasil dibuka")
        return ser
    except Exception as e:
        print(f"[UART ERROR] Gagal membuka serial port: {e}")
        return None

def process_image_multi_roi(frame, use_otsu=True):
    """Process image dengan multiple ROI yang lebih konservatif"""
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    
    if use_otsu:
        _, binary = cv2.threshold(blurred, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
    else:
        binary = cv2.adaptiveThreshold(blurred, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
                                       cv2.THRESH_BINARY_INV, 11, 2)
    
    # ROI lebih konservatif dengan jarak tidak terlalu jauh
    # ROI jauh (untuk preview): baris 120-150
    roi_far = binary[120:150, :]
    # ROI menengah: baris 150-190  
    roi_mid = binary[150:190, :]
    # ROI dekat: baris 190-230
    roi_near = binary[190:230, :]
    
    return gray, binary, roi_far, roi_mid, roi_near

def calculate_weighted_line_position(roi_far, roi_mid, roi_near):
    """
    Calculate line position dengan weighted average yang lebih balanced
    """
    kernel = np.ones((3,3), np.uint8)
    
    positions = []
    weights = []
    
    # Process ROI dekat (bobot tertinggi untuk stabilitas)
    roi_near_clean = cv2.morphologyEx(roi_near, cv2.MORPH_CLOSE, kernel)
    roi_near_clean = cv2.morphologyEx(roi_near_clean, cv2.MORPH_OPEN, kernel)
    M_near = cv2.moments(roi_near_clean)
    if M_near['m00'] > 100:
        cx_near = int(M_near['m10'] / M_near['m00'])
        positions.append(cx_near)
        weights.append(2.5)  # Bobot tertinggi
    
    # Process ROI menengah  
    roi_mid_clean = cv2.morphologyEx(roi_mid, cv2.MORPH_CLOSE, kernel)
    roi_mid_clean = cv2.morphologyEx(roi_mid_clean, cv2.MORPH_OPEN, kernel)
    M_mid = cv2.moments(roi_mid_clean)
    if M_mid['m00'] > 80:
        cx_mid = int(M_mid['m10'] / M_mid['m00'])
        positions.append(cx_mid)
        weights.append(1.5)
    
    # Process ROI jauh (untuk preview saja)
    roi_far_clean = cv2.morphologyEx(roi_far, cv2.MORPH_CLOSE, kernel)
    roi_far_clean = cv2.morphologyEx(roi_far_clean, cv2.MORPH_OPEN, kernel)
    M_far = cv2.moments(roi_far_clean)
    if M_far['m00'] > 60:  # threshold rendah untuk preview
        cx_far = int(M_far['m10'] / M_far['m00'])
        positions.append(cx_far)
        weights.append(0.8)  # Bobot rendah
    
    # Calculate weighted average
    if positions:
        weighted_sum = sum(pos * weight for pos, weight in zip(positions, weights))
        total_weight = sum(weights)
        weighted_cx = int(weighted_sum / total_weight)
        return True, weighted_cx, len(positions)
    
    return False, 0, 0

def compute_fuzzy_control_responsive(fuzzy_ctrl, error_val, delta_error):
    """Compute fuzzy control dengan range error yang sesuai"""
    try:
        # Clamp input values
        error_val = max(-160, min(160, error_val))
        delta_error = max(-80, min(80, delta_error))
        
        fuzzy_ctrl.input['error'] = error_val
        fuzzy_ctrl.input['delta'] = delta_error
        fuzzy_ctrl.compute()
        
        kontrol = fuzzy_ctrl.output['output']
        
        # Clip output untuk keamanan
        return np.clip(kontrol, -60, 60)
        
    except Exception as e:
        print(f"[FLC ERROR] {e}")
        return 0.0

def calculate_adaptive_motor_pwm(kontrol, base_pwm=55, scaling_factor=0.15, speed_boost=1.0):
    """
    Conservative PWM calculation untuk smooth movement
    """
    # Scaling yang lebih conservative
    adaptive_scale = scaling_factor * speed_boost
    kontrol_scaled = kontrol * adaptive_scale
    
    # Hitung PWM untuk masing-masing motor
    pwm_kiri = base_pwm + kontrol_scaled
    pwm_kanan = base_pwm - kontrol_scaled
    
    # Clamp PWM values ke range yang aman dan conservative
    pwm_kiri = max(30, min(75, pwm_kiri))
    pwm_kanan = max(30, min(75, pwm_kanan))
    
    return int(pwm_kiri), int(pwm_kanan)

def send_motor_commands(ser, pwm_kiri, pwm_kanan):
    if ser:
        try:
            cmd = f"{pwm_kiri},{pwm_kanan}\n"
            ser.write(cmd.encode())
            ser.flush()
        except Exception as e:
            print(f"[SERIAL ERROR] {e}")

def main():
    print("[SYSTEM] Starting Line Following Robot - Balanced Smooth Control")
    
    # Setup komponen
    fuzzy_ctrl = setup_fuzzy_logic_responsive()
    picam2 = setup_camera()
    ser = setup_serial()
    error_filter = ErrorFilter(window_size=3)  # Window size kembali normal
    
    # Variabel kontrol
    prev_error = 0
    frame_count = 0
    
    # Parameter yang lebih conservative
    BASE_PWM = 55           # Kecepatan dasar moderate
    SCALING_FACTOR = 0.15   # Scaling lebih conservative
    SPEED_BOOST = 1.0       # No boost for stability
    
    print(f"[CONFIG] Base PWM: {BASE_PWM}, Scaling: {SCALING_FACTOR}, Boost: {SPEED_BOOST}")
    print("[CONFIG] Balanced ROI: Far(120-150), Mid(150-190), Near(190-230)")
    
    try:
        while True:
            frame_count += 1
            
            # Capture dan process image dengan multiple ROI
            frame = picam2.capture_array()
            _, _, roi_far, roi_mid, roi_near = process_image_multi_roi(frame)
            
            # Deteksi posisi garis dengan weighted average
            line_detected, cx, roi_count = calculate_weighted_line_position(roi_far, roi_mid, roi_near)
            
            if line_detected:
                # Hitung error dan delta error
                error = cx - 160  # Setpoint di tengah (160)
                error = error_filter.filter_error(error)
                delta_error = error - prev_error
                prev_error = error
                
                # Conservative boost berdasarkan confidence
                current_boost = SPEED_BOOST * (1.0 + 0.05 * roi_count)
                
                # Compute FLC output
                kontrol = compute_fuzzy_control_responsive(fuzzy_ctrl, error, delta_error)
                
                # Hitung PWM dengan conservative scaling
                pwm_kiri, pwm_kanan = calculate_adaptive_motor_pwm(
                    kontrol, BASE_PWM, SCALING_FACTOR, current_boost
                )
                
                # Kirim command ke motor
                send_motor_commands(ser, pwm_kiri, pwm_kanan)
                
                # Debug info setiap 20 frame
                if frame_count % 20 == 0:
                    print(f"[DEBUG] ROI: {roi_count}, Error: {error:3d}, Delta: {delta_error:3d}, "
                          f"FLC: {kontrol:5.1f}, Boost: {current_boost:.1f}, PWM: L={pwm_kiri}, R={pwm_kanan}")
                
            else:
                # Garis tidak terdeteksi - rotasi sangat pelan untuk mencari garis
                send_motor_commands(ser, 40, 30)  # Rotasi kiri sangat pelan
                if frame_count % 20 == 0:
                    print("[DEBUG] Line not detected - searching slowly...")
            
            # Delay untuk stabilitas yang baik
            time.sleep(0.05)  # 20 FPS - lebih stabil
            
    except KeyboardInterrupt:
        print("\n[SYSTEM] Program dihentikan oleh user")
    except Exception as e:
        print(f"[ERROR] {e}")
    finally:
        # Cleanup
        send_motor_commands(ser, 0, 0)  # Stop motors
        if ser:
            ser.close()
        picam2.stop()
        print("[SYSTEM] Cleanup completed")  # Window lebih kecil untuk respons cepat
    
    # Variabel kontrol
    prev_error = 0
    frame_count = 0
    
    # Parameter yang dapat disesuaikan
    BASE_PWM = 60           # Kecepatan dasar sedikit lebih tinggi
    SCALING_FACTOR = 0.3    # Scaling lebih agresif
    SPEED_BOOST = 1.2       # Boost untuk respons cepat
    
    print(f"[CONFIG] Base PWM: {BASE_PWM}, Scaling: {SCALING_FACTOR}, Boost: {SPEED_BOOST}")
    print("[CONFIG] Multi-ROI: Far(100-140), Mid(140-180), Near(180-220)")
    
    try:
        while True:
            frame_count += 1
            
            # Capture dan process image dengan multiple ROI
            frame = picam2.capture_array()
            _, _, roi_far, roi_mid, roi_near = process_image_multi_roi(frame)
            
            # Deteksi posisi garis dengan weighted average
            line_detected, cx, roi_count = calculate_weighted_line_position(roi_far, roi_mid, roi_near)
            
            if line_detected:
                # Hitung error dan delta error
                error = cx - 160  # Setpoint di tengah (160)
                error = error_filter.filter_error(error)
                delta_error = error - prev_error
                prev_error = error
                
                # Adaptive speed boost berdasarkan jumlah ROI yang mendeteksi
                current_boost = SPEED_BOOST * (1.0 + 0.1 * roi_count)
                
                # Compute FLC output
                kontrol = compute_fuzzy_control_responsive(fuzzy_ctrl, error, delta_error)
                
                # Hitung PWM dengan adaptive scaling
                pwm_kiri, pwm_kanan = calculate_adaptive_motor_pwm(
                    kontrol, BASE_PWM, SCALING_FACTOR, current_boost
                )
                
                # Kirim command ke motor
                send_motor_commands(ser, pwm_kiri, pwm_kanan)
                
                # Debug info setiap 15 frame (lebih sering)
                if frame_count % 15 == 0:
                    print(f"[DEBUG] ROI: {roi_count}, Error: {error:3d}, Delta: {delta_error:3d}, "
                          f"FLC: {kontrol:5.1f}, Boost: {current_boost:.1f}, PWM: L={pwm_kiri}, R={pwm_kanan}")
                
            else:
                # Garis tidak terdeteksi - rotasi pelan untuk mencari garis
                send_motor_commands(ser, 35, 25)  # Rotasi kiri pelan
                if frame_count % 15 == 0:
                    print("[DEBUG] Line not detected - searching...")
            
            # Delay lebih kecil untuk respons lebih cepat
            time.sleep(0.03)  # ~33 FPS
            
    except KeyboardInterrupt:
        print("\n[SYSTEM] Program dihentikan oleh user")
    except Exception as e:
        print(f"[ERROR] {e}")
    finally:
        # Cleanup
        send_motor_commands(ser, 0, 0)  # Stop motors
        if ser:
            ser.close()
        picam2.stop()
        print("[SYSTEM] Cleanup completed")

if __name__ == '__main__':
    main()
